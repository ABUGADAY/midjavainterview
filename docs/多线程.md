### 1.什么是线程
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。
### 2.线程和进程有什么区别
线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存控件。别把它和栈内存搞混，每个线程都拥有单独的栈内存哦你过来存储本地数据。
### 3.如何在Java中实现线程
在语言层面有两种方式。Java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口，所以你可以继承java.lang.Thread类或者直接调用Runnable接口来重写run()方法实现线程。
### 4.用Runnable还是Thread？
如果你要继承其他类，调用Runnable接口好。
### 6.Thread类中的start()和run()方法有什么区别？
start()方法被用来启动新创建的线程，而start()内部调用了run()方法，这和直接调用run()方法的效果不一样。run()只会在原来的线程中调用,start()会启动新线程。
### 7.Java中Runnable和Callable有什么不同
Runnable和Callable都代表那些要在不同的线程中执行的任务。区别主要是Callable的call()方法可以返回值和抛出异常，而run()没有这些功能。Callable可以返回装载有计算结果的Future对象。
### 8.Java中CyclicBarrier和CountDownLatch有什么不同？
CyclicBarrier和CointDownLatch都可以用来让一组线程等待其他线程。与CyclicBarrier不同的是，CountDownLatch不能重新使用
### 9.Java内存模型是什么？
Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性的行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其他线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：
* 前一个对volatile的写操作在后一个volatile的读操作之前，也叫做管程锁定规则。
* 一个线程内的任何操作必须在这个线程的start()之后，也叫做线程启动规则。
* 一个线程的所有操作都会在线程终止之间，线程终止规则
* 一个对象的中介操作必须在这个对象构造完成之后，也叫对象终结规则。
* 可传递性

### 10.Java中的volatile变量是什么？
volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其他线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是volatile变量规则。
### 11.什么是线程安全？Vector是一个线程安全类吗？
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值和预期的是一样的，就是线程安全的。Vector是用同步方法来实现线程安全的，而和它类似的ArrayList不是线程安全的。
### 12.Java中什么是竞态条件？
竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现并且会重复痴线，因为线程间的随机竞争，一个例子就是无序处理。
### 13.Java中如何停止一个线程？
当run()或者call()方法执行完的时候线程会自动结束，如果要手动结束一个线程，可以用volatile布尔变量来推出run()方法的循环或者是取消任务来中断线程。
### 14.一个线程运行时发生异常会怎样？
简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将纤层和异常作为参数传递给hanfler的uncaughtException()方法进行处理。
### 15.如何在两个线程间共享数据？
可以通过共享对象来实现这个目的，或者是使用想阻塞队列这样并发的数据结构。
### 16.Java中notify和notifyAll有什么区别？
notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许它们争夺锁确保了至少能有一个线程能继续运行。
### 17.为什么wait,notify 和 notifyAll这些方法不在thread类里面？
由于wait，notify和notifyAll都是锁级别的操作，所以把它们定义在Object类中因为锁属于对象。
### 18.什么是ThreadLoacal变量？
ThreadLocal是Java里的一种特殊的变量。每个线程都已一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。他是为创建代价高昂的对象获取线程安全的好方法，比如SimpleDateFormat。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Randon对象个数。
### 19.什么是FutureTask？
在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能区队，如果运算尚未完成get方法将阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。
### 20.Java中interrupted和isInterrupted方法的区别？
interrupted()和isInterrupted()的主要区别是前者会将中断状态清楚而后者不会。Java多线程的中断机制使用内部标识来实现的,调用Thread.interrupted()来中断一个线程会设置中断标识为true。当中断线程调用静态方法Thread.interrupt()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted() 用来查询其他线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有可能被其他线程调用中断来改变。
### 21.为什么wait和notify方法要在同步块中调用？
主要是因为Hava API强制要求这么做，如果你不这么做，你的代码就会排除IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。
### 22.为什么你应该在循环中检查等待条件？
处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因。
### 23.Java中的同步集合与并发集合有什么区别？
同步集合与并发集合都为多线程和并发提供了合适的线程池安全的集合，不过并发集合的可扩展性更高。
### 24.Java中堆和栈有什么不同？
每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其他线程是不可见的。而对是所有线程共享的一片公共内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这是volatile变量就可以发挥作用了，他要求线程从主存中读取变量的值。
### 25.什么是线程池？为什么使用它？
创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题在程序启动的时候就会创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程吃，每次处理一个任务；数目固定的线程池或者是缓存线程池(一个适合很多生存期短的任务的程序的可扩展线程池)
### 26.如何写代码来解决生产者消费者问题？
在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其他线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法 是用wait和notify来解决这个问题，比较赞的方法是用Semphore或者BlokingQueue来实现生产者消费者模型

### 27.如何避免死锁？
Java多线程中的死锁
死锁是指两个或以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：
* 互斥条件：一个资源每次只能被一个进程使用。
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺条件；进程已获得的资源，在未完成使用之前，不能强行剥夺。
* 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
  避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位，排序，规定所有的进程申请资源必须以一定的顺序(升序或降序)做操作来避免死锁。

### 28.活锁和死锁有什么区别
活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊饥饿。一个显示的活锁例子就是两个人在狭小的走廊碰到，两个人都是这避让对方好让彼此通过，却因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变却不能继续执行。
### 29.怎么检测一个线程是否拥有锁？
在java.lang.Thread中有一个方法叫holesLock()，它返回true如果当且晋档当前线程拥有某个具体对象的锁。
### 30.如何在Java中获取线程堆栈？
对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl+Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。
### 31.JVM中哪个参数是用来控制线程的堆栈大小的？
-Xss参数
### 32.Java中synchronized 和 ReentrantLock有什么不同？
Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界。尝试获取锁时不能中途取消等。Java5通过Lock接口提供了更复杂的控制来解决这些问题。ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，并且它还有可扩展性。
### 33.有三个线程T1 T2 T3 怎么确保它们按顺序执行？
在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(t3t3调用t2调用t1)，这样T1就会先完成而T3最后完成。
### 34.Thread类中yield方法有什么作用？
yield方法可以暂停当前正在执行的线程对象，让其他有相同优先级的线程执行。它是一个静态方法，而且只保证当前线程放弃CPU占用而不能保证其他线程 一定能占用CPU，执行yield的线程有可能在进入到暂停状态后马上又被执行。
### 35.Java中ConcurrenthashMap的并发度是什么？
ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。
### 36.Java中Semaphore是什么？
Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上将，信号量维护了一个许可集合。如果有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不适用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，如数据库连接池。
### 37.如果你提交任务时，线程池队列已满，会发生什么
如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常
### 38.Java线程池中submit()和execute()方法有什么区别？
两个方法都可以向线程吃提交任务，execute()方法的返回类型时void,它定义在Executor接口中，而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口。
### 39.什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，线程会被挂起，直到得到结果之后才会返回。此外还有异步和非阻塞式方法再任务完成前就返回。
### 40.Swing是线程安全的吗？
Swing不是线程安全的。当我们说Swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。
### 41.Java中invokeAndWait和invokeLater有什么区别？
这两个方法是Swing API提供给Java开发这用来从事当前线程而不是时间派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应的改变。如果进度被多个线程跟踪，那么调用invokeAndWait()方法请求时间派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。
### 42.Swing API中哪些方法是线程安全的？
虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(),revalidate()。JtextComponent的setText()方法和JTextArea的insert()和append()方法也是线程安全的。
### 43.如何在Java中创建Immutable(不可变)对象？
通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。
### 44.Java中的ReadWriteLock是什么？
一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java5中新增的一个接口，一个ReadWriteLock维护一堆关联的锁，一个用于只读操作一个用于写。在没有写线程的情况写一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以用JDK中的ReentrantReadWriteLock来实现这个规则，它最多被65535个写锁和65535个读锁。
### 45.多线程中的忙循环是什么？
忙循环就是程序员用一个循环让一个线程等待，不像传统方法wait(),sleep()或yield()它们都放弃了CPU控制，而忙循环不会放弃CPU,它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。
### 46.volatile变量和atomic变量有什么不同？
volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用volatile修饰count变量那么count++操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAdnIncrement()方法会原子性的进行增量操作把当前值加一，其他数据类型的引用和变量也可以进行相似操作。
### 47.如果同步块内的线程抛出异常会发生什么？
无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花精力去释放锁，该功能可以在finally block里释放锁实现。
### 48.单例模式的双检锁是什么？

### 49.如何在Java中创建线程安全的Singleton(单例)
可以利用JVM的类加载和静态变量初始化特征创建Singleton实例，或者是利用枚举类型来创建Singleton。
### 50.写出3条你遵循的多线程最佳实践
* 给你的线程起个有意义的名字
* 避免锁定和缩小同步的范围
* 多用同步类少用wait和notify
* 多用并发集合少用同步集合

### 51.如何强制启动一个线程？
目前没有办法

### 52.Java中的fork Join框架是什么？
是JDK7中出现的一款充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其他线程中窃取任务来执行。

### 53.Java多线程中调用wait()和sleep()方法有什么不同？
Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。